#+options: toc:nil ^:nil
#+begin_export md
---
layout: post
title:  "Rust的Tips"
date:   2022-01-10
tags:
      - it
---
#+end_export
#+TOC: headlines 1

* 12个Rust的Tips
https://rustcc.cn/article?id=84fc469b-51d4-4437-91fd-980f69838699

1. 使用 Cow<str> 作为返回类型
1. 使用 Crossbeam channels 取代标准库
1. 使用 Scopeguard 实现类似 Golang 的延迟运算
1. 使用 Cargo-make 打包
1. 自定义和链接 Panic 处理程序
1. 在 VSCode 中使用 Rust Analyzer
1. 用到闭包时使用 impl Trait
1. 在保存时为 VSCode 启用 Clippy
1. 使用 thiserror 和 anyhow 处理惯用错误
1. 使用 dbg!() 替换 println!()
1. 使用 include_str!() 和 include_bytes!() 宏在编译时读取文件
1. 使用 cc crate 与 C/C++ 代码交互
1. 判断汉字。在Rust中，一个英文字符或者阿拉伯数字是占一个字节的，而一个汉字是占3个字符串。可以使用std::mem::size_of_val()方法查看在内存占用几个字节。\\
   https://www.jianshu.com/p/844537218e6e

   http://wilson-blog.cn/post/2021/04/26/rust.chstr.html\\
   https://course.rs/basic/base-type/char-bool.html
* rust 实用 crates
1. Dioxus -- a new Rust GUI toolkit for Web, Desktop, Mobile, SSR, TUI that emphasizes developer experience
1. Salvo -- 简易的http server.

* 基于 Rust 编写的实用命令行工具
https://zhuanlan.zhihu.com/p/356091194

  1. alacritty 使用 GPU 加速的跨平台终端模拟器
  1. starship 超级快、支持各种订制的极简命令行提示符，支持任意 shell
  1. exa ls 现代版
  1. bat 支持更多特性的 cat 克隆
  1. delta git、diff 输出查看器
  1. zoxide 更快捷地浏览文件系统
  1. ripgrep 基于正则表达式递归搜索目录
  1. fd 简单、快速、用户友好的 find 替代品
  1. bottom 又一个跨平台的图形化进程/系统查看器
  1. tldr 众人一起编写的终端命令速查卡
  1. spotify-tui Spotify 客户端命令行版
  1. gitui 超级 快的 git 字符界面客户端
   
* rust 疑难分析
** PhantomData
   https://zhuanlan.zhihu.com/p/383004091
   #+begin_src rust
     pub struct Rc<T: ?Sized> {
	 ptr: NonNull<RcBox<T>>,
	 phantom: PhantomData<RcBox<T>>,
     }
   #+end_src
   PhantomData主要目的是标记这个Rc结构体拥有这个RcBox<T>，实际不占用空间，告诉编译器在drop Rc的时候会drop掉RcBox<T>。
   - Rust drop 数据的顺序如下：
     - 变量是它们声明顺序的逆序
     - struct的fields，是fields的声明顺序
   
   一个例子：
   #+begin_src rust
   	 struct World<'a> {
         inspector: Option<Inspector<'a>>, //相当于a: &b
         days: Box<u8>,                    //相当于b
   	 }

   	 struct Inspector<'a>(&'a u8);

   	 impl<'a> Drop for Inspector<'a> {
         fn drop(&mut self) {
   	   println!("I was only {} days from retirement!", self.0);
         }
   	 }

   	 fn main() {
         let mut world = World {
   	   inspector: None,
   	   days: Box::new(1),
         };
         world.inspector = Some(Inspector(&world.days)); // a = &b
   	 }

   #+end_src

   rustc main.rs 出错了。虽然理论上inpsector先被销毁，但是编译器还是认为days 没有strictly outlive inspector，也就是days 没有outlive world。是不是有点意外？如果你就是要编译通过呢？因为刚刚我们已经分析清楚，inspector先销毁的并且它的drop函数也没有干见不得人的事情，所以是安全的（注意实际代码不要依赖这种顺序，至少目前不要）。Rust有个特性叫drop_eyepatch，结合#[may_dangle[]可以让代码编译通过

#+name: struct_pic
#+begin_src ditaa :cache yes :eval no-export :file ../images/struct.png :cmdline -r
    +-----------+       +---------+
    | World     |       |         |
    +-+---------+       |Inspector|
      |inspector| -=--> |         |
      |---------|       |         |
      |days     | <--=- |         |
      +---------+       +---------+
   #+end_src

#+name: pic_link   
#+begin_src shell  :result html :var pic=struct_pic[:eval query-export]() :wrap EXPORT markdown :exports results
  file="/images/$(basename $pic)"
  echo "![img]($file)"
#+end_src

#+RESULTS: pic_link
#+begin_EXPORT markdown
![img](/images/struct.png)
#+end_EXPORT

   或者说rustc没有那么智能，不去判断struct顺序上的依赖关系？

   这样是错误的。
   #+begin_src rust
     struct Foo<T> {
         name: *mut T,
     }
     impl<T> Foo<T> {
         fn new(init: T) -> Self {
   	  Self {
   	      name: Box::into_raw(Box::new(init)),
   	  }
         }
     }
     impl<T> Drop for Foo<T> {
         fn drop(&mut self) {
   	  {
   	      unsafe{ Box::from_raw(self.name);}
   	  }
         }
     }
     // 是的，&_s的生命周期比_a要短，所以不通过是正常的。
     fn main1() {
         let _a;
         let _s = "hello world".to_owned();
         _a = Foo::new(&_s);
     }
     // 因为声明为(_a, _s)编译器仍然认为_s不是 strictly alive _a，所以要报错。
     fn main2() {
         let (_a, _s);
         _s = "hello world".to_owned();
         _a = Foo::new(&_s);
     }

   #+end_src
   这时候作为程序员，你知道这两个main函数都是安全的（为什么呢？留给读者思考）。因此Rust也提供了#[may_dangle ]特技，让你编译通过。我们只要借助#[may_dangle]将drop函数改为如下，就可以通过编译。
   #+begin_src rust
     #![feature(dropck_eyepatch)] // !!add the beginning of the file
     unsafe impl<#[may_dangle] T> Drop for Foo<T> {
         fn drop(&mut self) {
   	  // try to drop T as we owns it
   	  unsafe { Box::from_raw(self.name); }
         }
     }
   #+end_src
   这是因为#[may_dangle]告诉编译器虽然T有dangle pointer，但是我们不会访问，所以是安全的，请让它通过编译。但是这么修改以后，Foo<T>就会接收下面的Bad 结构体，出现UB。
   #+begin_src rust
     struct Bad<T:Debug>(T);
     impl<T:Debug> Drop for Bad<T> {
         fn drop(&mut self) {
   	  println!("{:?}", self.0);
         }
     }
     fn main() {
         let _a;
         let _s = "evil dog".to_owned();
         let _b = Bad(&_s);
         _a = Foo::new(_b);
     }
   #+end_src
   通过反思，我们希望当T有定义drop函数的时候，我们要拒绝接受它，从而避免出现这样的问题。而PhantomData就是我们的好帮手。所以我们将Foo<T>修改如下
   #+begin_src rust
     use std::marker::PhantomData;

     struct Foo<T> {
         name: *mut T,
         _marker: PhantomData<T>,
     }
     impl<T> Foo<T> {
         fn new(init: T) -> Self {
   	  Self {
   	      name: Box::into_raw(Box::new(init)),
   	      _marker: PhantomData
   	  }
         }
     }
   #+end_src
   通过这个例子我们就深刻明白了PhantomData与#[may_dangle] 珠联璧合，实现了下面的目的

      - 如果T拥有自定义的drop函数，那么编译器仍然要T strictly outlive Foo。
      - 如果T没有自定义的drop函数，那么就不要求 T outlive Foo<T>。

** 语法代码例子
#+begin_src rust
  #![allow(unused)]                                                               

  pub struct Ui {}                                                                
  // 也就是ComponentBuilder
  pub trait Component<Params, Content> {                                          
      fn call(&self, ui: &mut Ui, params: Params, content: Content);              
  }                                                                               
  // 约束一个函数类型实现ComponentBuilder， 其中Content也就是ContentBuilder
  impl<F, P1, P2, Content> Component<(P1, P2), Content> for F                     
  where P1: PartialEq + Clone + 'static,                                      
	P2: PartialEq + Clone + 'static,                                      
	Content: FnOnce(&mut Ui),                                             
	F: Fn(&mut Ui, P1, P2, Content)                                       
  {                                                                               
      fn call(&self, ui: &mut Ui, params: (P1, P2), content: Content) {           
	  let (p1, p2) = params;
	  self(ui, p1, p2, content)                                               
      }                                                                           
  }                                                                               
  // 范式创建Component, 可以用不同的param和content builder.
  pub fn memoize<Params: PartialEq + Clone + 'static,                             
		 C: FnOnce(&mut Ui),                                              
		 Comp: Component<Params, C>>(                                     
      ui: &mut Ui, component: Comp, params: Params, content: C) {                 
      component.call(ui, params, content);                                        
  }                                                                               
  // 用了具体的param创建Component
  fn comp2(ui: &mut Ui, a: u8, b: u32, f: impl FnOnce(&mut Ui)) { f(ui); }        

  fn main() {                                                                     
      let mut ui = Ui {};
      // 直接用comp2也可以，但调用范式更整洁一点。
      memoize(&mut ui, comp2, (2, 3), |_| {});
  }                                                                               
#+end_src

同样的例子，用宏实现多参数函数。

#+begin_src rust

  pub struct Ui {
  }


  pub trait Component {
      type Params: PartialEq + Clone + 'static;
      type Content: FnOnce(&mut Ui);

      fn call(&self, ui: &mut Ui, params: Self::Params, content: Self::Content);
  }


  impl<C: for<'c> FnOnce(&'c mut Ui)> Component for for <'c> fn(&'c mut Ui, C) {
      type Params = ();
      type Content = C;

      fn call(&self, ui: &mut Ui, params: Self::Params, content: Self::Content) {
	  self(ui, content);
      }
  }


  macro_rules! component_args {
      ($($P: tt),+) => {
	  #[allow(non_snake_case)]
	  impl<$($P: Clone + PartialEq + 'static),*, C: for<'c> FnOnce(&'c mut Ui)> Component
	      for for<'c> fn(&'c mut Ui, $($P),*, C)
	  {
	      type Params = ($($P),*);

	      type Content = C;

	      fn call(&self, ui: &mut Ui, params: Self::Params, content: Self::Content) {
		  let ($($P),*) = params;
		  self(ui, $($P),*, content);
	      }
	  }
      };
  }

  component_args!(P1);
  component_args!(P1, P2);
  component_args!(P1, P2, P3);
  component_args!(P1, P2, P3, P4);
  component_args!(P1, P2, P3, P4, P5);
  component_args!(P1, P2, P3, P4, P5, P6);
  component_args!(P1, P2, P3, P4, P5, P6, P7);
  component_args!(P1, P2, P3, P4, P5, P6, P7, P8);
  component_args!(P1, P2, P3, P4, P5, P6, P7, P8, P9);
  component_args!(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10);

  pub fn memoize<
	  Params: PartialEq + Clone + 'static,
      C: for<'c> FnOnce(&'c mut Ui),
      Comp: Component<Params = Params, Content = C>,
      >(
      ui: &mut Ui,
      component: Comp,
      params: Params,
      content: C,
  ) {
      component.call(ui, params, content);
  }


  fn comp(ui: &mut Ui, s: usize, f: impl FnOnce(&mut Ui)) {
      f(ui);
  }


  fn main() {
      let mut ui = Ui {};
      memoize(&mut ui, comp, (1,), |_|{})
  }
#+end_src
参考 https://zjp-cn.github.io/rust-note/dcl/variadic.html

** 一个元素的Tuple
语法是("single", ) 如果写成("single"), rustc会提示你去掉多余的(), 并且如果你想要Tuple,那么加个逗号。("single", )

** generic_associated_types

如何将trait里面的associated type指定life time  https://rust-lang.github.io/rfcs/1598-generic_associated_types.html

** A new impl Trait (by davidkoloski)

https://davidkoloski.me/blog/a-new-impl-trait-1/
提出了一些问题

#+begin_src rust
fn pick(which: bool, x: impl Debug, y: impl Debug) -> impl Debug {
    if !which {
        x
    } else {
        y
    }
}
#+end_src

是不行的，因为x,y可能是不同的类型。现在的impl Trait有2个缺陷，（A new impl Trait 4/4 ）
The largest obstacle for as impl Trait will be building consensus for either type inference or named unnameables.

- 类型推导 type inference
  
- 不可命名类型的命名 named unnameable types.
  
  
