---
layout: post
title: "c++语法真有点吓人"
date: 2018-11-30
tags: 
    - it
---

# Table of Contents

1.  [c++11语法甜点](#org89db843)
2.  [C++14的return type deduction](#orga2e9e4c)
3.  [c++真有点吓人](#org98d2744)
4.  [When weakptr useful](#orgd21310f)

<a id="org89db843"></a>

# c++11语法甜点

 <https://www.cnblogs.com/cpper-kaixuan/>
C++ 11中引入了许多简化编程工作的语法上的新特性，我们暂且美其名曰“语法甜点”。下面一一进行介绍。


## 语法甜点 1：序列for循环

序列for循环是一种简化的for循环，可用于遍历一组序列，包括各种容器、string、数组、初始化列表以及由begin和end函数定义的序列。示例代码如下：

    vector<int> vctTemp{1, 2, 3};
    for (auto a : vctTemp)
    {
        cout << a << endl;
    }


## 语法甜点 2：委托构造函数

在引入C++ 11之前，如果某个类有多个重载的构造函数，且这些构造函数中有一些共同的初始化逻辑，通常都需要再编写一个带参数的初始化函数，然后在这些构造函数中调用这个初始化函数。在C++ 11中，再也不用这么麻烦了。我们可以实现一个最基础的构造函数，其他构造函数都调用这个构造函数。示例代码如下：

    class CPerson
    {
    public:
     CPerson() : CPerson(0, "") { NULL; }
     CPerson(int nAge) : CPerson(nAge, "") { NULL; }
     CPerson(int nAge, const string &strName)
     {
      stringstream ss;
      ss << strName << "is " << nAge << "years old.";
      m_strInfo = ss.str();
     }
    
    private:
     string m_strInfo;
    };


## 语法甜点 3：统一的初始化语法

在引入C++ 11之前，有各种不同的初始化语法。在C++ 11中，仍可以使用这些初始化语法，但也可以选择使用新引入的统一的初始化语法。统一的初始化语法用一对大括号{}表示，使用{}初始化语法还可有效地避免窄转换。示例代码如下：

    int a{5};
     char c{'X'};
     int p[5] = {1, 2,3, 4, 5};
     vector<int> vctTemp{1, 2, 3};
     CPerson person{10, "Mike"};
      int b = 5.3;                     // b赋值成5，发生了窄转换
      int d{5.3};                      // 会提示编译错误，避免了窄转换


## 语法甜点 4：nullptr

nullptr是C++ 11中新加的一个关键字，用于标识空指针。引入nullptr后，可以解决某些函数重载时的二义性问题。示例代码如下：

    void F(int a)
    {
     cout << a << endl;
    }
    
    void F(char *p)
    {
     assert(p != NULL);
    
     cout << p << endl;
    }
    
    int main(int argc, _TCHAR* argv[])
    {
     int *p = nullptr;
     int *q = NULL;
     bool bEqual = (p == q);  // 两个指针值是相等的，bEqual为true
     int a = nullptr;   // 编译失败，nullptr不是转换为int
    
     F(0);          // 在C++ 98中编译失败，有二义性；在C++ 11中调用F(int)
     F(nullptr);    // 调用F(char *)
    
     getchar();
     return 0;
    }


## 语法甜点 5：成员变量初始化

与Java和C#中的用法一样，可以对成员变量进行就地初始化。示例代码如下：

    class CPerson
    {
    private:
     int m_nAge = 10;
     string m_strName = "Mike";
    };


## 语法甜点 6：默认或禁用函数

当我们定义了自己的带参数的构造函数时，编译器将不再生成默认的构造函数，如果此时想使用默认的构造函数，则必须显式地声明并定义不带参数的构造函数。在C++ 11中，我们可以使用default关键字来表明我们希望使用默认的构造函数。类似的，当我们不想外部使用编译器自动生成的构造函数或赋值函数时，我们一般需要将其声明成protected或private的。在C++ 11中，我们可以使用delete关键字来表明我们不希望编译器生成默认的构造函数或赋值函数。示例代码如下：

    class CPerson
    {
    public:
     CPerson() = default;
     CPerson(const CPerson &person) = delete;
    };


## 语法甜点 7：继承的构造函数

当一个派生类的某个函数隐藏了基类中的某个同名函数时，如果我们想在派生类中导出基类中的这个同名函数，可以通过using Base::Func的方式将基类中的这个同名函数引入到派生类的作用域内。当该方法只对普通成员函数有效，不能用于构造函数。在C++ 11中，如果派生类认为基类的构造函数已经足够，则也可以使用using Base::Base的方式将基类的构造函数引入到派生类的作用域内。但需要注意的是，此时派生类中的成员变量并没有进行初始化，所以应当对这些成员变量进行就地初始化。示例代码如下：

    class CBase
    {
    };
    
    class CDerived : public CBase
    {
    public:
     using CBase::CBase;
     CDerived(int nData) : m_nData(nData) { NULL; }
    
    private:
     int m_nData = 10;
    };


## 语法甜点 8：模板右边双括号

在C++ 98中，vector<vector<int>> vctTemp是一个非法的表达式，编译器会认为右边的>>是一个移位操作符，因此必须修改为vector<vector<int>> vctTemp，即在右边的两个>中间添加一个空格。在C++ 11中，这将不再是一个问题，编译器将能够识别出右边的双括号是两个模板参数列表的结尾。


## 语法甜点 9：static<sub>assert</sub>

静态断言static<sub>assert由一个常量表达式和一个字符串构成</sub>。在编译期间，将计算常量表达式的值，如果为false，字符串将作为错误信息输出。示例代码如下：

    char a = 10;
    static_assert(sizeof(a)==4, "a is not an integer.");


## 语法甜点 10：初始化列表

在引入C++ 11之前，只有数组能使用初始化列表。在C++ 11中，vector、list等各种容器以及string都可以使用初始化列表了。初始化列表对应的类为initializer<sub>list</sub>，vector、list等各种容器以及string之所以可以使用初始化列表，是因为它们重载了参数类型为initializer<sub>list的构造函数</sub>（称为初始化列表构造函数）和赋值函数（称为初始化列表赋值函数）。下面是一些使用初始化列表的例子。

    void Print(const initializer_list<int> &ilData)
    {
      for (auto a : ilData)
        {
          cout << a << endl;
        }
    }
    
    int main(int argc, _TCHAR* argv[])
    {
      vector<int> vctNum = {1, 2, 3, 4, 5};
      map<string, string> mapID2Name = {
        {"92001", "Jack"},
        {"92002", "Mike"}
      };
      string strText{"hello world"};
      Print({});
      Print({1, 2});
      Print({1, 2, 3, 4, 5});
    
      getchar();
      return 0;
    }


<a id="orga2e9e4c"></a>

# C++14的return type deduction

<https://www.newsmth.net/nForum/#!article/CPlusPlus/374960>

若干年前实现了一个 C++ 序列化库，以前一直纠结于一种优化无法（自动）实现： 

    struct A { int a1, a2; }; 
    
    struct B { int b1, b2; }; 
    
    struct C { A ca; B cb; }; 
    
    struct D { std::set d; }; 
    
    DATA_IO_LOAD_SAVE_E(A, &a1 &a2) // 序列化 A 的 a1, a2 成员，下同 
    
    DATA_IO_LOAD_SAVE_E(B, &b1 &b2) 
    
    DATA_IO_LOAD_SAVE_E(C, &ca &cb) 
    
    DATA_IO_LOAD_SAVE_E(D, &d)      // stl 容器也可以序列化 

如果使用 NativeDataInput/Output, 只能自动推断出 A, B 可以直接 memcpy，无法推断出 C 也可以 memcpy，当然，任何情况下 D 肯定都是 无法 memcpy 的 现在有了 return type deduction, C memcpy 的问题就解决了 

参考链接： <https://www.nfabo.cn/p/?p=65> 

递归实现推导的. &a1 &a2 这样的表达式只能出现在 成员函数 内部，从而只有 return type deduction 才能
推导出相应的 type traits，DATA<sub>IO</sub><sub>LOAD</sub><sub>SAVE</sub><sub>E</sub> 宏定义中有类似这样的代码：

    auto DeduceMemCpyTrait(AutoDeducer deducer) {
       // 这是一个成员函数
       // Members 就是 &a1 &a2 这样的表达式
       // AutoDeducer 重载 operator& 进行类型推导
       return deducer Members;
    }
    typedef decltype(DeduceMemCpyTrait(AutoDeducer()) MemCpyTrait; 


<a id="org98d2744"></a>

# c++真有点吓人

<https://www.newsmth.net/nForum/#!article/CPlusPlus/403674>

下面的英文是从教程里摘出来的。然后有点没看懂：make<sub>unique</sub> 是cpp14引入的，  在这之前，下面叙述里的 foo 函数要怎么写才可以避免意外的内存泄露呢？   

> If your compiler does not yet support make<sub>unique</sub>() , you can   create your unique<sub>ptr</sub> as follows. Note that Simple must be mentioned twice:   
>   unique<sub>ptr</sub><Simple> mySimpleSmartPtr(new Simple());
> Before C++17, you had to use make<sub>unique</sub>() not only because you have to specify the type only once, but also because of safety reasons!
> Consider the following   call to a function called foo() :     
> foo(unique<sub>ptr</sub><Simple>(new Simple()), unique<sub>ptr</sub><Bar>(new Bar(data())));
> If the constructor of Simple or Bar , or the data() function, throws an exception, depending on your compiler optimizations, it was very possible that either a Simple or a Bar object would be leaked. 

按照后人的说法：

unique<sub>ptr</sub><T> t(new T())本身不危险

关键不在于一个对象产生的内存泄漏，c++不至于傻逼到ctor里面抛异常了连这个对象本身的内存都回收不了。这里的关键是传进去2个对象，当1个对象的ctor抛异常后能不能回收new另一个对象时候分配的内存。 
要点就是一旦new成功就立刻交给一个智能指针，这就是为啥要用make<sub>unique</sub>

也就是说 A\* p=new A(); 如果A()抛出异常的话，那么p=null. 即对象本身的内存回收了。

关键在于gcc 的优化，

    foo(unique_ptr<Simple>(new Simple()), unique_ptr<Bar>(new Bar(data()))); 

可以变成： 

new Simple()

new Bar(data())

unique<sub>ptr</sub><Simple>

unique<sub>ptr</sub><Bar>

只能说是悲剧的gcc，太害人了。

refer: <https://blog.csdn.net/u011475134/article/details/76714243>

refer: <https://blog.csdn.net/Jxianxu/article/details/72859800?utm_source=blogxgwz0>

要点就是一旦new成功就立刻交给一个智能指针，这就是为啥要用make<sub>unique</sub> 对于make<sub>unique处理不了的private</sub> ctor，就只能由factory method直接返回unique<sub>ptr</sub>   全部代码： 

    #include <memory>
    #include <iostream>
    using namespace std;
    
    template <bool Exception>
    class A {
      public:
       static unique_ptr<A> Create()  {
         unique_ptr<A> p(new A);
         return p;
       }
    
       void* operator new(size_t size) {
         void* p = malloc(size);
         cout << "allocate " << size << " bytes at " << p << endl;
         return p;
       }
    
       void operator delete(void* p) {
         cout << "free " << p << endl;
         free(p);
       }
    
      private:
       A() {
         if (Exception) {
           cout << "throw exception\n";
           throw 0;
         }
       }
    
       int date;
    };
    
    template <class First, class Second>
    void Foo(unique_ptr<First> first, unique_ptr<Second> second) { }
    
    int main() {
       try {
         auto p = A<true>::Create();
       } catch (...) {}
    
       try {
         Foo(A<true>::Create(), A<false>::Create());
       } catch (...) {}
    
       try {
         Foo(A<false>::Create(), A<true>::Create());
       } catch (...) {}
    } 

智能指针之make<sub>unique与make</sub><sub>shared</sub>
附录： <https://blog.csdn.net/u011475134/article/details/76714243> 


## make<sub>unique的实现</sub>

std::make<sub>shared是C</sub>++11的一部分，但是std::make<sub>unique很可惜不是</sub>。它是在C++14里加入标准库的，但我们可以自己实现make<sub>unique方法</sub>。

    
    // 支持普通指针
    template<class T,class... Args> inline
      typename enable_if<!is_array<T>::value,unique_ptr<T>>::type
      make_unique(Args&&... args){
      return unique_ptr<T>(new T(std::forward<Args>(args)...));
    }
    
    // 支持动态数组
    template<class T> inline
    typename enable_if<is_array<T>::value && extent<T>::value == 0, unique_ptr<T>>::type
    
      make_unique(size_t size){
      typedef typename remove_extent<T>::type U;
      return unique_ptr<T>(new U[size]());
    }
    
    // 过滤掉定长数组的情况
    template<class T,class... Args>
      typename enable_if<extent<T>::value != 0,void>::type
      make_unique(Args&&...) = delete;


## enable<sub>if的作用</sub>

    // Primary template.
    /// Define a member typedef @c type only if a boolean constant is true.
    
    template<bool, typename _Tp = void>
    
      struct enable_if
    
     { };
    
    // Partial specialization for true.
    
    template<typename _Tp>
    
      struct enable_if<true, _Tp>
    
     { typedef _Tp type; };

结合源码可知，当condition==true时，enable<sub>if</sub><condition,T>::type ≡ T，否则报错。

enable<sub>if</sub><!is<sub>array</sub><T>::value,unique<sub>ptr</sub><T>>::type的condition在T不是数组类型时为true

enable<sub>if</sub><is<sub>array</sub><T>::value && extent<T>::value == 0,unique<sub>ptr</sub><T>>::type的condition在T为数组类型且数组中元素个数为0时为true，由于对于非数组类型extent<U>::value也为0，语句is<sub>array</sub><T>::value是必要的

enable<sub>if</sub><extent<T>::value != 0,void>::type的condition在T类型中元素个数不为0时为true，即T为定长数组


## std::forward的作用

std::forward在这里的作用是实现参数的完美转发，具体见《move和forward源码分析[转]》。


## make函数的好处

1.  效率更高

shared<sub>ptr需要维护引用计数的信息</sub>。如果你通过使用原始的new表达式分配对象，然后传递给shared<sub>ptr</sub>（也就是使用shared<sub>ptr的构造函数</sub>）的话，shared<sub>ptr的实现没有办法选择</sub>，而只能单独的分配控制块：

如果选择使用make<sub>shared的话</sub>，情况就会变成下面这样：

内存分配的动作，可以一次性完成。这减少了内存分配的次数，而内存分配是代价很高的操作。

1.  异常安全

看看下面的代码：

    void F(const hstd::shared_ptr<Lhs>& lhs, const std::shared_ptr<Rhs>& rhs)
    { /* ... */ }
    
    F(std::shared_ptr<Lhs>(new Lhs("foo")), std::shared_ptr<Rhs>(new Rhs("bar")));

C++是不保证参数求值顺序，以及内部表达式的求值顺序的，所以可能的执行顺序如下：

new Lhs("foo"))

new Rhs("bar"))

std::shared<sub>ptr</sub>

std::shared<sub>ptr</sub>

假设在第2步的时候，抛出了一个异常（比如out of memory，总之，Rhs的构造函数异常了），那么第一步申请的Lhs对象内存泄露了。这个问题的核心在于，shared<sub>ptr没有立即获得裸指针</sub>。

我们可以用如下方式来修复这个问题：

    auto lhs = std::shared_ptr<Lhs>(new Lhs("foo"));
    
    auto rhs = std::shared_ptr<Rhs>(new Rhs("bar"));
    
    F(lhs, rhs);

当然，推荐的做法是使用std::make<sub>shared来代替</sub>：

F(std::make<sub>shared</sub><Lhs>("foo"), std::make<sub>shared</sub><Rhs>("bar"));

当std::make<sub>shared被调用</sub>，指向动态内存对象的原始指针会被安全的保存在返回的std::shared<sub>ptr对象中</sub>，然后另一std::make<sub>shared被调用</sub>。如果此时产生了异常，那std::shared<sub>ptr析构会知道于是它所拥有的对象会被销毁</sub>。

使用std::make<sub>unique来代替new在写异常安全的代码里和使用std</sub>::make<sub>shared一样重要</sub>。


## make函数的不足

make函数都不允许使用定制删除器，但是std::unique<sub>ptr和std</sub>::shared<sub>ptr的构造函数都可以</sub>。


### make函数不能完美传递一个initializer<sub>list</sub>。

替代方案：

    // initializer_list<int> aa = {1,2,3}; // 或者
    
    auto aa = {1,2,3};
    
    auto a = make_shared<vector<int>>(aa);
    
    // auto b = make_shared<vector<int>>({1,2,3}); // 错误


### 对象的内存可能无法及时回收

虽然使用std::make<sub>shared可以减少了内存分配的次数</sub>，提高效率，但由于控制块与对象都在同一块动态分配的内存上，所以当对象的引用计数变为0，对象被销毁（析构函数被调）后，该对象所占内存仍未释放，直到控制块同样也被销毁，内存才会释放。

我们知道，在控制块中包含两个计数：shared count和weak count，分别表示std::shared<sub>ptr和std</sub>::weak<sub>ptr对对象的引用计数</sub>，只有当shared count和weak count都为0时，控制块才会被销毁。

换句话说，只要有std::weak<sub>ptr指向一个控制块</sub>（weak count大于0），那控制块就一定存在。只要控制块存在，包含它的内存必定存在。通过std::shared<sub>ptr的make函数分配的内存在最后一个std</sub>::shared<sub>ptr和最后一个std</sub>::weak<sub>ptr被销毁前不能被释放</sub>。


## 构造函数是保护或私有时，无法使用make<sub>shared</sub>。

替代方案：

    class A {
    
    public:
    
      static std::shared_ptr<A> create() {
    
      return std::make_shared<A>();
    
     }
    
    protected:
    
      A() {}
    
      A(const A &) = delete;
    
      const A &operator=(const A &) = delete;
    
    };
    
    std::shared_ptr<A> foo() {
    
      return A::create();
    
    }

作者：SigalHu

来源：CSDN 

原文：<https://blog.csdn.net/u011475134/article/details/76714243> 

版权声明：本文为博主原创文章，转载请附上博文链接！

refer： [When is std::weak<sub>ptr</sub> useful?](https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful)


<a id="orgd21310f"></a>

# When weakptr useful

use<sub>countrefer</sub>: [When is std::weak<sub>ptr</sub> useful?](https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful)


## weak<sub>ptr可以判断游荡的指针是否可用</sub>。

> std::weak<sub>ptr</sub> is a very good way to solve the [dangling pointer](https://en.wikipedia.org/wiki/Dangling_pointer) problem.
> By just using raw pointers it is impossible to know if the
> referenced data has been deallocated or not. Instead, by letting a
> std::shared<sub>ptr</sub> manage the data, and supplying std::weak<sub>ptr</sub> to users of
> the data, the users can check validity of the data by calling expired()
> or lock().

应用场景：

-   cache objects. 可以用weak ptr
    保存这些objects，看看他们谁还在用，谁已经无效了。当然这种情况用shared<sub>ptr的use</sub><sub>count判断为1也可以</sub>。The
    cache use case could work with a shared reference if the cache was
    able to test if the refcount is 1, thus knowing it has the only
    reference and it could release it reclaiming on demand. This would
    eliminate the need for weak references in this case.

-   交叉引用问题。

Suppose you have Team and Member objects.

Obviously it's a relationship : the Team object will have pointers to
its Members. And it's likely that the members will also have a back
pointer to their Team object.

Then you have a dependency cycle. If you use shared<sub>ptr</sub>, objects will no
longer be automatically freed when you abandon reference on them,
because they reference each other in a cyclic way. This is a memory
leak.

You break this by using weak<sub>ptr</sub>. The "owner" typically use shared<sub>ptr</sub>
and the "owned" use a weak<sub>ptr</sub> to its parent, and convert it temporarily
to shared<sub>ptr</sub> when it needs access to its parent.

Store a weak ptr :

weak<sub>ptr</sub><Parent> parentWeakPtr\_ = parentSharedPtr; // automatic
conversion to weak from shared

then use it when needed

shared<sub>ptr</sub><Parent> tempParentSharedPtr = parentWeakPtr<sub>.lock</sub>(); // on
the stack, from the weak ptr

if( not tempParentSharedPtr ) {  // yes it may failed if parent was
freed since we stored weak<sub>ptr</sub>

} else {  // do stuff

}// tempParentSharedPtr is released when it goes out of scope

-   管理进程std::shared<sub>ptr</sub><Task>给subtask周期分配任务，std::vector<std::weak<sub>ptr</sub><Task>>。用timer查看std::weak<sub>ptr</sub><Task>是否还存在。Suppose
    you have a collection of tasks, executed asynchronously, and managed
    by an std::shared<sub>ptr</sub><Task>. You may want to do something with those
    tasks periodically, so a timer event may traverse a
    std::vector<std::weak<sub>ptr</sub><Task>> and give the tasks something to do.
    However, simultaneously a task may have concurrently decided that it
    is no longer needed and die. The timer can thus check whether the task
    is still alive by making a shared pointer from the weak pointer and
    using that shared pointer, provided it isn't null.

